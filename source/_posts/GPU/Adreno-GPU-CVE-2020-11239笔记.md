---
title: Adreno GPU CVE-2020-11239笔记
date: 2021-09-07 14:16:36
tags: [GPU,高通,CVE]
categories: 笔记
description: CVE-2020-11239是高通GPU kgsl驱动的一个UAF漏洞，可能造成任意代码执行，本文仅对其成因进行分析，不做利用分析。
---

原文地址: [github security lab](https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/)

高通GPU驱动在上一篇介绍CVE-2020-11179的博客中已经进行了介绍，这里不做介绍。

# 漏洞成因

## 漏洞位置

漏洞存在于`IOCTL_KGSL_GPUOBJ_IMPORT`和`IOCTL_KGSL_MAP_USER_MEM`这两个ioctl调用中，他们是用来创建app和kgsl驱动之间的共享内存的。调用这两个ioctl接口时，用户需要指定:

+ 一个用户空间的地址
+ 共享内存的大小
+ 内存类型

这两个ioctl调用会将用户空间的内存映射到GPU的内存中。不同的内存类型会使得kernel会使用不同的机制来map和access用户内存。这里的内存类型分为两种:

+ 直接I/O: 直接将用户空间地址映射到设备，不需要通过内核，这在编程上很方便，但是存在同步上的问题，开销也很大。
+ DMA: 分配物理地址连续的DMA buffer，设备直接对buffer进行读写，读写过程不需要CPU接入，通过中断同步。

在`kgsl_ioctl_gpuobj_import`中有如下实现:

````c++
long kgsl_ioctl_gpuobj_import(struct kgsl_device_private *dev_priv,
		unsigned int cmd, void *data)
{
    ...
	if (param->type == KGSL_USER_MEM_TYPE_ADDR)
		ret = _gpuobj_map_useraddr(dev_priv->device, private->pagetable,
			entry, param);
	else	//DMA
		ret = _gpuobj_map_dma_buf(dev_priv->device, private->pagetable,
			entry, param, &fd);
    ...
}
````

## android设备中的DMA创建

在android中，和设备共享一个DMA buffer的过程如下:

+ 用户使用ion分配器创建一个DMA buffer。在android中，ion是DMA的具体实现，它们二者有相同含义。如`KGSL_USER_MEM_TYPE_DMABUF`和`KGSL_USER_MEM_TYPE_ION`含义相同
+ ion分配器从ion heap中分配内存，该区域是`kmalloc`系列分配函数对应的heap。
+ ion分配器返回一个文件描述符fp作为handle给用户。
+ 用户将fp作为参数，通过ioctl调用传给设备。
+ 设备通过`dma_buf_get`和`dma_buf_attach`获取并把自身attach到DMA buffer。
+ 设备通过`dma_buf_map_attachment`获取DMA buffer的`sg_table`，`sg_table`是用来存储不连续的内存块列表的，DMA可以通过`sg_table`去读写不连续的物理地址。
+ 最终，用户和设备均可访问该DMA buffer，这时用户需要通过`DMA_BUF_IOCTL_SYNC`来保证二者的同步。

DMA buffer使用结束后，使用`dma_buf_unmap_attachment`, `dma_buf_detach`, 和`dma_buf_put`释放dma。

## 成因

kgsl通过`dma_buf_unmap_attachment`获取了用户提供的DMA buffer的`sg_table`，并将其存放在`kgsl_mem_entry->memdesc.sgt`中:

````c++
static int kgsl_setup_dma_buf(struct kgsl_device *device,
				struct kgsl_pagetable *pagetable,
				struct kgsl_mem_entry *entry,
				struct dma_buf *dmabuf)
{
	...
	sg_table = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);

	if (IS_ERR_OR_NULL(sg_table)) {
		ret = PTR_ERR(sg_table);
		goto out;
	}

	dma_buf_unmap_attachment(attach, sg_table, DMA_BIDIRECTIONAL);

	meta->table = sg_table;
	entry->priv_data = meta;
	entry->memdesc.sgt = sg_table;
	...
}
````

在`IOCTL_KGSL_MAP_USER_MEM`中，直接从用户提供内存的页表来创建一个新的sgt:

````c++
static int memdesc_sg_virt(struct kgsl_memdesc *memdesc, unsigned long useraddr)
{
	...
	ret = sg_alloc_table_from_pages(memdesc->sgt, pages, npages,
					0, memdesc->size, GFP_KERNEL);
	...
}
````

当ioctl中某一步失败时，`kgsl_mem_entry`会被销毁，销毁逻辑取决于内存类型有所不同，DMA的内存类型的某一个失败时的销毁过程如下:

````c++
long kgsl_ioctl_gpuobj_import(struct kgsl_device_private *dev_priv,
		unsigned int cmd, void *data)
{
    ...
	ret = kgsl_mem_entry_attach_process(dev_priv->device, private, entry);
	if (ret)
		goto unmap;
	...

unmap:
	if (kgsl_memdesc_usermem_type(&entry->memdesc) == KGSL_MEM_ENTRY_ION) {
		kgsl_destroy_ion(entry->priv_data);
		entry->memdesc.sgt = NULL;
	}

	kgsl_sharedmem_free(&entry->memdesc);
    ...
}
````

在`kgsl_sharedmem_free`中，对sgt进行了释放:

````c++
void kgsl_sharedmem_free(struct kgsl_memdesc *memdesc)
{
    ...
	if (memdesc->sgt) {
		sg_free_table(memdesc->sgt);
		kfree(memdesc->sgt);
	}

	if (memdesc->pages)
		kgsl_free(memdesc->pages);
}
````

问题出在`kgsl_ioctl_gpuobj_import`中，这个调用原本用来处理DMA buffer的的共享，但是它也处理了用户传入的参数表示内存类型是用户地址`KGSL_USER_MEM_TYPE_ADDR`的情况:

````c++
long kgsl_ioctl_gpuobj_import(struct kgsl_device_private *dev_priv,
		unsigned int cmd, void *data)
{
    ...
	if (param->type == KGSL_USER_MEM_TYPE_ADDR)
		ret = _gpuobj_map_useraddr(dev_priv->device, private->pagetable,
			entry, param);
	else
		ret = _gpuobj_map_dma_buf(dev_priv->device, private->pagetable,
			entry, param, &fd);
   	...
}
````

而在`_gpuobj_map_useraddr`中，最后调用了`kgsl_setup_useraddr`，该函数中首先尝试将用户提供的地址当作DMA buffer进行分配，失败后再继续进行正常的用户地址映射共享。

这时，如果用户提供的地址是由ion分配器分配的，就会创建一个ION类型的内存对象，该ION类型的`memdesc->sgt`指向DMA的sgt。

梳理一下，用户使用`kgsl_ioctl_gpuobj_import`调用，且参数表明提供的内存是`KGSL_USER_MEM_TYPE_ADDR`，但实际地址是ion分配器分配的DMA内存时，最终会创建一个ION类型的`memdesc`，其sgt指向DMA的sgt。这时`kgsl_mem_entry_attach_process`若出错，会进入unmap中，这时会直接释放掉`memdesc->sgt`。而实际上DMA buffer还没有被释放，在4.12内核版本后，仍可以通过`dma_buf_attachment`获取sgt:

````c++
static int ion_dma_buf_attach(struct dma_buf *dmabuf, struct device *dev,
                                struct dma_buf_attachment *attachment)
{
    ...
        table = dup_sg_table(buffer->sg_table);
    ...
        a->table = table;                          //<---- c. duplicated table stored in attachment, which is the output of dma_buf_attach in a.
    ...
        mutex_lock(&buffer->lock);
        list_add(&a->list, &buffer->attachments);  //<---- d. attachment got added to dma_buf::attachments
        mutex_unlock(&buffer->lock);
        return 0;
}
````

`ion_dma_buf_attach`将sgt放在了`dma_buf_attachment->a->sgt`中。此后，若再调用`DMA_BUF_IOCTL_SYNC`，会导致该sgt被使用:

````c++
static int __ion_dma_buf_begin_cpu_access(struct dma_buf *dmabuf,
                                          enum dma_data_direction direction,
                                          bool sync_only_mapped)
{
    ...
        list_for_each_entry(a, &buffer->attachments, list) {
        ...
                if (sync_only_mapped)
                        tmp = ion_sgl_sync_mapped(a->dev, a->table->sgl,        //<--- use-after-free of a->table
                                                  a->table->nents,
                                                  &buffer->vmas,
                                                  direction, true);
                else
                        dma_sync_sg_for_cpu(a->dev, a->table->sgl,              //<--- use-after-free of a->table
                                            a->table->nents, direction);
            ...
                }
        }
...
}
````

这造成了一个UAF漏洞，利用该漏洞可以造成任意代码执行。

[patch](https://source.codeaurora.org/quic/la/kernel/msm-3.18/commit/?id=20e2434473b259b40b590099da9fbce02a37cc8a):

````diff

diff --git a/drivers/gpu/msm/kgsl.c b/drivers/gpu/msm/kgsl.c
index f62de5a..7ed6f2876 100644
--- a/drivers/gpu/msm/kgsl.c
+++ b/drivers/gpu/msm/kgsl.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2019, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2008-2020, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -2311,7 +2311,7 @@ long kgsl_ioctl_gpuobj_import(struct kgsl_device_private *dev_priv,
 	return 0;
 
 unmap:
-	if (param->type == KGSL_USER_MEM_TYPE_DMABUF) {
+	if (kgsl_memdesc_usermem_type(&entry->memdesc) == KGSL_MEM_ENTRY_ION) {
 		kgsl_destroy_ion(entry->priv_data);
 		entry->memdesc.sgt = NULL;
 	}
@@ -2620,7 +2620,7 @@ long kgsl_ioctl_map_user_mem(struct kgsl_device_private *dev_priv,
 	return result;
 
 error_attach:
-	switch (memtype) {
+	switch (kgsl_memdesc_usermem_type(&entry->memdesc)) {
 	case KGSL_MEM_ENTRY_ION:
 		kgsl_destroy_ion(entry->priv_data);
 		entry->memdesc.sgt = NULL;
````

